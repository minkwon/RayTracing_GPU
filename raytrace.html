<!DOCTYPE html>
<html lang="en">
<head>
    <script src="js/gpu.min.js"></script>
    <script src="js/three.js"></script>
    <script src="js/helper.js"></script>
    <script src="js/scene.js"></script>
    <script src="js/raytracer.js"></script>
    <link rel="stylesheet" type="text/css" href="styleGenerator.css">
    <meta charset="UTF-8">
    <title>Ray tracing with javascript using GPU.js</title>
</head>
<body>

<input type="button" value="Using GPU" onclick="return changeMode(this);" />
<div id = "fps"></div>
<script>

    // configurations
    // rows and columns must evenly divide image height/weight!

    var IMAGE_WIDTH = 1000;
    var IMAGE_HEIGHT = 1000;
    var ROWS = 10;
    var COLUMNS = 10;

    var allowCPUMode = false;

    // configuration ends

    var CANVAS_WIDTH = IMAGE_WIDTH / COLUMNS;
    var CANVAS_HEIGHT = IMAGE_HEIGHT / ROWS;

    var gpu = new GPU();
    // helper functions to be used inside the kernel
    gpu.addFunction(lightIsBlockedByObject);
    gpu.addFunction(getVectorLength);
    gpu.addFunction(dotProduct);
    var f = document.querySelector("#fps");

    // button event handler, toggles between two modes
    // 0: CPU mode, 1: GPU mode (default
    var selection = 1;
    if (allowCPUMode) {
        function changeMode(el) {
            if (el.value == "Using CPU") {
                selection = 1;
                el.value = "Using GPU";
            } else {
                selection = 0;
                el.value = "Using CPU";

            }
        }
    } else {
        function changeMode(el) {
            el.value = "not configured to use CPU";
        }
    }

    // animation

    var m = 0;
    var cameraMoving = 0;
    function animate() {
        m = (m + 3) % 360;
        objects[23] = 120 * Math.cos((m / 360) * 2 * Math.PI);
        objects[11] = 120 * Math.cos((m / 360) * 2 * Math.PI);
        objects[36] = 65 * Math.cos((m / 360) * 2 * Math.PI) - 60;
        objects[38] = 65 * Math.sin((m / 360) * 2 * Math.PI) + 200;

        // only recalculate perspective info if position of camera changed
        if (cameraMoving == 1) {
            info = getPerspectiveInfo(camera);
        }
    }

    // This info is shared between all rays so it is calculated serially.
    var info = getPerspectiveInfo(camera);

    var gpuRender = doit('gpu', CANVAS_WIDTH, CANVAS_HEIGHT);
    var cpuRender = doit('cpu', CANVAS_WIDTH, CANVAS_HEIGHT);

    // first render
    // first render is done with GPU so it speeds up the loading.
    for (var row = 0; row < ROWS; row++) {
        for (var col = 0; col < COLUMNS; col++) {
            // arguments to be passed
            var arg = [gpu, row, col, ROWS, COLUMNS, IMAGE_WIDTH, IMAGE_HEIGHT];

            // sends shader source for WebGl, to GPU
            gpuRender(camera, lights, objects, info, arg);

            // copy the resulting image data generated by rendering with shader source from WebGL
            var imgData = copyImageDataFromWebGlCanvas(gpuRender.getCanvas());

            // create new element called canvas
            var newCanvas = document.createElement("canvas");
            // set attributes of canvas
            newCanvas.setAttribute("id", "gpuframe" + row + col);
            newCanvas.setAttribute("width", CANVAS_WIDTH);
            newCanvas.setAttribute("height", CANVAS_HEIGHT);

            // putting the image data to the new canvas
            var newCanvasCtx = newCanvas.getContext("2d");
            newCanvasCtx.putImageData(imgData, 0, 0);
            document.getElementsByTagName('body')[0].appendChild(newCanvas);

//
//            if (allowCPUMode) {
//                cpuRender(camera, lights, objects, info, arg);
//                var cpuCanvas = cpuRender.getCanvas();
//                cpuCanvas.setAttribute("id", "cpuframe" + row + col);
//                document.getElementsByTagName('body')[0].appendChild(cpuCanvas);
//            }
        }
    }
    function renderLoop() {
        for (var row = 0; row < ROWS; row++) {
            for (var col = 0; col < COLUMNS; col++) {
                // arguments to be passed
                var arg = [gpu, row, col, ROWS, COLUMNS, IMAGE_WIDTH, IMAGE_HEIGHT];

                // gpu mode
                if (selection == 1) {
                    if (allowCPUMode) {
                        document.getElementById("cpuframe" + row + col).style.visibility = "hidden";
                        document.getElementById("gpuframe" + row + col).style.visibility = "visible";
                    }
                    // sends shader source for WebGl, to GPU
                    gpuRender(camera, lights, objects, info, arg);

                    // copy the resulting image data generated
                    var imgData = copyImageDataFromWebGlCanvas(gpuRender.getCanvas());

                    // grab the corresponding canvas
                    var thisCanvas = document.getElementById("gpuframe" + row + col);
                    var thisCanvasCtx = thisCanvas.getContext("2d");

                    // put the image data
                    thisCanvasCtx.putImageData(imgData, 0, 0);
                // cpu mode
                } else {
                    document.getElementById("gpuframe" + row + col).style.visibility = "hidden";
                    document.getElementById("cpuframe" + row + col).style.visibility = "visible";
                    cpuRender(camera, lights, objects, info, arg);
                    var previous = document.getElementById("cpuframe" + row + col);
                    var body = previous.parentNode;
                    var newCanvas = cpuRender.getCanvas();
                    body.replaceChild(newCanvas, previous);
                    newCanvas.setAttribute("id", "cpuframe" + row + col);
                }
            }
        }
        f.innerHTML = fps.getFPS();
        animate();
        requestAnimationFrame(renderLoop);
    }
    window.onload = renderLoop;

</script>

</body>
</html>