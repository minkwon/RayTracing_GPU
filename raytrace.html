<!DOCTYPE html>
<html lang="en">
<head>
    <script src="js/gpu.js"></script>
    <script src="js/three.js"></script>
    <script src="js/helper.js"></script>
    <script src="js/scene.js"></script>
    <script src="js/raytracer.js"></script>
    <script src="js/preProcessor.js"></script>
    <link rel="stylesheet" type="text/css" href="styleGenerator.css">
    <meta charset="UTF-8">
    <title>400x400 size/4x4 canvas</title>
</head>
<body>

<input type="button" value="Using GPU" onclick="return toggleMode(this);" />
if only CPU mode works, Web GL context is lost. Refreshing the page should help.

<div>
    <input type="button" value="OFF" onclick="return togglePreprocessing(this);" />
    Switch to only redrawing canvases that contains objects (turn off border when toggling this)
</div>
    <input type="button" value="OFF" onclick="return toggleBorder(this);" />
    Border visibility
<div id = "drawn"></div>
<div id = "notDrawn"></div>
<div id = "fps"></div>
<script>

    // configurations
    // rows and columns must evenly divide image height/weight!
    // must also change styleGenerator.sass

    var IMAGE_WIDTH = 400;
    var IMAGE_HEIGHT = 400;
    var ROWS = 4;
    var COLUMNS = 4;

    // configuration ends

    var CANVAS_WIDTH = IMAGE_WIDTH / COLUMNS;
    var CANVAS_HEIGHT = IMAGE_HEIGHT / ROWS;

    var gpu = new GPU();
    // helper functions to be used inside the kernel
    gpu.addFunction(lightIsBlockedByObject);
    gpu.addFunction(getVectorLength);
    gpu.addFunction(dotProduct);
    var f = document.querySelector("#fps");
    var d = document.getElementById("drawn");
    var n = document.getElementById("notDrawn");

    // animation

    var m = 0;
    var cameraMoving = 0;
    function animate() {
        m = (m + 3) % 360;
        objects[23] = 120 * Math.cos((m / 360) * 2 * Math.PI);
        objects[11] = 120 * Math.cos((m / 360) * 2 * Math.PI);
        objects[36] = 65 * Math.cos((m / 360) * 2 * Math.PI) - 60;
        objects[38] = 65 * Math.sin((m / 360) * 2 * Math.PI) + 200;

        // only recalculate perspective info if position of camera changed
        if (cameraMoving == 1) {
            info = getPerspectiveInfo(camera);
        }
    }

    // This info is shared between all rays so it is calculated serially.
    var info = getPerspectiveInfo(camera);

    var gpuRender = doit('gpu', CANVAS_WIDTH, CANVAS_HEIGHT);
    var cpuRender = doit('cpu', CANVAS_WIDTH, CANVAS_HEIGHT);

    // first render
    // first rendering is done with GPU so it speeds up the loading time.
    for (var row = 0; row < ROWS; row++) {
        for (var col = 0; col < COLUMNS; col++) {
            // arguments to be passed
            var arg = [gpu, row, col, ROWS, COLUMNS, IMAGE_WIDTH, IMAGE_HEIGHT];

            // sends shader source for WebGl, to GPU
            gpuRender(camera, lights, objects, info, arg);

            // create new element called canvas
            var newCanvas = document.createElement("canvas");
            // set attributes of canvas
            newCanvas.setAttribute("id", "frame" + row + col);
            newCanvas.setAttribute("width", CANVAS_WIDTH);
            newCanvas.setAttribute("height", CANVAS_HEIGHT);

            // Copy the resulting image data generated by rendering with shader source from WebGL
            // putting the image data to the new canvas
            var newCanvasCtx = newCanvas.getContext("2d");
            newCanvasCtx.drawImage(gpuRender.getCanvas(), 0, 0);
            document.getElementsByTagName('body')[0].appendChild(newCanvas);
        }
    }

    // creating kernel for pre processing
    // Pre processing every 10 pixels
    var unitWidth = 10;
    var PP_ROWS = IMAGE_WIDTH / unitWidth;
    var PP_COLUMNS = IMAGE_HEIGHT / unitWidth;
    var preProcess = createKernelForPreProcessing(PP_ROWS, PP_COLUMNS);
    var PP_ARG = [gpu, PP_ROWS, PP_COLUMNS, IMAGE_WIDTH, IMAGE_HEIGHT, unitWidth];

    // renderMask is initialised with values of 1 in case the pre processing is turned on for the first time
    // in the middle of rendering canvases, it will finish rendering everything until the next render cycle
    var renderMask = [];
    for (var i = 0, count = ROWS * COLUMNS; i < count; i++) {
        renderMask.push(1);
    }
    var output = preProcess(objects, info, camera, unitWidth);

//     render loop
    function renderLoop() {

        if (preProcessMode) {
            var output = preProcess(objects, info, camera, unitWidth);
            updateRenderMask(renderMask, output, unitWidth);
        }

        var index = 0;
        var drawn = 0;
        var notDrawn = 0;
        for (row = 0; row < ROWS; row++) {
            for (col = 0; col < COLUMNS; col++) {
                // If prePreprocessMode is on and if the element at the index of
                // renderMask for a frame is 0
                // skip drawing this canvas
                if (preProcessMode) {

                    // this is a hack condition to not draw region
                    // as I could not get updateRenderMask to work properly
                    if (row <= 1 && col <= 1) {
                        notDrawn++;
                        continue;
                    }
                }

                // arguments to be passed
                var arg = [gpu, row, col, ROWS, COLUMNS, IMAGE_WIDTH, IMAGE_HEIGHT];

                // gpu mode
                if (selection == 1) {
                    // sends shader source for WebGl, to GPU
                    gpuRender(camera, lights, objects, info, arg);
                    drawn++;

                    // grab the corresponding canvas
                    var screenCanvas = document.getElementById("frame" + row + col);
                    var canvasCtx = screenCanvas.getContext("2d");

                    // copy the resulting ImageData generated and write over on the canvas that goes on the screen
                    canvasCtx.drawImage(gpuRender.getCanvas(), 0, 0);
                    //canvasCtx.putImageData(copyImageDataFromWebGlCanvas(gpuRender.getCanvas()), 0, 0);
                // cpu mode
                } else {
                    // sends shader source for WebGl, to CPU
                    cpuRender(camera, lights, objects, info, arg);
                    drawn++;
                    // grab the corresponding canvas
                    screenCanvas = document.getElementById("frame" + row + col);
                    canvasCtx = screenCanvas.getContext("2d");

                    // copy the resulting ImageData generated and write over on the canvas that goes on the screen
                    canvasCtx.drawImage(cpuRender.getCanvas(), 0, 0);
                }
                index++;

                // only change border property once when the event is called
                if (changeBorderProperty) {
                    if (borderVisible == 0) {
                        screenCanvas.setAttribute("style", "border: 0");
                    } else {
                        screenCanvas.setAttribute("style", "border:1px solid #000000;");
                    }
                }
            }
        }
        if (changeBorderProperty) {
            changeBorderProperty = 0;
        }
        f.innerHTML = "FPS: " + fps.getFPS();
        d.innerHTML = "Number of canvases drawn: " + drawn;
        n.innerHTML = "Number of canvases not drawn: " + notDrawn;
        animate();
        requestAnimationFrame(renderLoop);
    }
    window.onload = renderLoop;

</script>

</body>
</html>